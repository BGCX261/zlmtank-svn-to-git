#ifndef _IO_H
#define _IO_H







// i386 I/O 操作使用独立地址空间的端口向量
// 分别使用 IN 和 OUT 来读写这些向量来操作硬件端口
// 端口向量为 0 - 65535 由硬件厂商来定义其功能
// 具体信息只能查阅相关资料获取
// 一般来说端口分为三种类型：
// 1，数据寄存器，这一个端口用于写入数据到硬件设备
// 2. 控制寄存器，向这个端口写入控制命令数据，来操作设备
// 3. 状态寄存器，读该端口获取硬件设备的信息状态

// IN/OUT 可以操作 8 位字节、16 位字(CPU 16 位模式下）和
// 32 位字(32 位模式下)，以及使用 INS 和 OUTS 操作字节序列
// 这里只是定义了基本的 byte 字节操作

// 另外，硬件一般是慢速设备(相对于 CPU 来说)。不可能跟随
// CPU 的指令的速度来运转。所以在 I/O 操作端口之后必须执行
// 空操作让 CPU 等待硬件设备消化 I/O 操作指令
// i386 本身空指令为 NOP 但其效果不理想，仅 2 到 3 个周期
// 而使用 JMP $ 手动跳转到下一个指令可以有 7 到 10 个周期

// io_writebyte(): 写字节 vaule 到端口 port
#define io_writebyte(port, value)	\
	__asm__ __volatile__(	\
		"outb %%al,%%dx"	\
		:	\
		:"a" (value),"d" (port)	\
	)

// io_readbyte(): 从端口 port 读一个字节返回
#define io_readbyte(port) ({	\
	unsigned char _v;	\
	__asm__ __volatile__(	\
		"inb %%dx,%%al"	\
		:"=a" (_v)	\
		:"d" (port)	\
	);	\
	_v; \
})

// io_writebyte_p(): 写字节 vaule 到端口 port
// 操作完成后有延时（等待端口处理）
#define io_writebyte_p(port, value)	\
	__asm__ __volatile__(	\
		"outb %%al,%%dx\n"	\
		"\tjmp 1f\n"	\
		"1:\tjmp 1f\n"	\
		"1:"	\
		:	\
		:"a" (value),"d" (port)	\
	)

// #define io_readbyte_p(): 从端口 port 读一个字节返回
// 操作完成后有延时（等待端口处理）
#define io_readbyte_p(port) ({	\
	unsigned char _v;	\
	__asm__ __volatile__ (	\
		"inb %%dx,%%al\n"	\
		"\tjmp 1f\n"	\
		"1:\tjmp 1f\n"	\
		"1:"	\
		:"=a" (_v)	\
		:"d" (port)	\
	);	\
	_v;	\
})

// 以下两个宏用于保护现场
// 相当多数 I/O 操作需要在操作前后保护恢复标志寄存器

// io_lock(): 入栈保存标志寄存器，并禁止中断
#define io_saveflag(x)	\
	__asm__ __volatile__(	\
		"pushfl\n\t"	\
		"popl %0\n\t"	\
		"cli"	\
		:"=g" (x)	\
		:	\
		:"memory"	\
	)

// io_unlock(): 出栈恢复标志寄存器
#define io_restoreflag(x)	\
	__asm__ __volatile__(	\
		"pushl %0\n\t"	\
		"popfl"	\
		:	\
		:"g" (x)	\
	)



//--------------------------------------------------------------------------------------------------------------------------
//
//  读取 CMOS 端口
//
//--------------------------------------------------------------------------------------------------------------------------
#define io_readcmos(addr) ({\
io_writebyte_p(0x70 , addr | 0x80);\
io_readbyte_p(0x71);\
})

//--------------------------------------------------------------------------------------------------------------------------
//
//  IO设备延迟
//
//--------------------------------------------------------------------------------------------------------------------------
#define io_wait()   io_readbyte(0x80)

//--------------------------------------------------------------------------------------------------------------------------
//
//  核心延迟
//
//--------------------------------------------------------------------------------------------------------------------------
#define io_kerneldelay()  \
  __asm__ __volatile__ ("pushal \n\t"\
			"mov $0x3F6, %dx \n\t" \
			"inb %dx, %al \n\t"    \
			"inb %dx, %al \n\t"    \
			"inb %dx, %al \n\t"    \
			"inb %dx, %al \n\t"    \
			"popal")




#endif

